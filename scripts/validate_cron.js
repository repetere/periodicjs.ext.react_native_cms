'use strict';
const Promisie = require('promisie');
const fs = Promisie.promisifyAll(require('fs-extra'));
const LintStream = require('jslint').LintStream;
const lintOptions = {
	edition: 'latest',
	es6: true,
	node: true,
  strict: true,
  white: true,
  this: true,
  multivar: true
};
const linter = new LintStream(lintOptions);
/**
 * Contains certain linting rule modifiers that are not covered by jslint options. Uses regexs to filter out certain errors by message content prints result to process stdout and exits
 * @param  {Object} chunk Data that is emitted by linter
 * @param {Object} chunk.linted Contains lint data about the file
 * @param {Array} chunk.linted.error An array of error codes and associated messages generated by linter
 */
const handleLint = function (chunk) {
	try {
		if (chunk.linted && Array.isArray(chunk.linted.errors) && chunk.linted.errors.length) {
			let validErrors = chunk.linted.errors.filter(error => {
				let validError = true;
				//Removes error cause by using fat arrow functions, let, $ object properties, certain regexp formats and single argument fat arrow functions
				if (/.+instead\s?saw\s?.+(\[|let|\=\>)/.test(error.message)) {
					validError = false;
				}
				if (/Bad\s+Property.+\${1}\w+/i.test(error.message)) {
					validError = false;
				}
				if (/Expected.+\({1}.+before/i.test(error.message)) {
					validError = false;
				}
				if (/Wrap\s+this\s+regexp\s+/i.test(error.message)) {
					validError = false;
				}
				return validError;
			});
			if (validErrors.length) {
				console.log('ERRORS', validErrors);
			}
			else {
				console.log('Valid');
			}
		}
		else {
			console.log('Valid');
		}
		process.exit(0);
	}
	catch (e) {
		console.log('There was a linting error', e);
		process.exit(0);
	}
};
linter.on('data', handleLint);
(function (argv) {
	//Pulls file path arguments from process.argv array
	let filePath = (function () {
		let val;
		for (let i = 0; i < argv.length; i++) {
			val = i;
			if (argv[i] === '--filePath') {
				break;
			}
		}
		val = (typeof argv[val + 1] === 'string') ? argv[val + 1] : null;
		return val;
	})();
	fs.readFileAsync(filePath, 'utf8')
		.then(filedata => {
			//Writes file data to linter stream for linting
			linter.write({
				file: filePath,
				body: filedata
			});
		}, e => {
			console.log('There was a file read error', e);
			process.exit(0);
		});
})(process.argv);